import type { Nullable, ReaderSync, xml_document, xml_node, xml_text } from "./_types.js";
export type { Nullable, ReaderSync, xml_document, xml_node, xml_text };
/** XML parser options. */ export type options = {
  /** Remove elements from result. */ clean?: {
    /** Remove attributes from result. */ attributes?: boolean;
    /** Remove comments from result. */ comments?: boolean;
    /** Remove XML doctype from result. */ doctype?: boolean;
    /** Remove XML processing instructions from result. */ instructions?: boolean;
  };
  /** Flatten result depending on node content. */ flatten?: {
    /** If node only contains attributes values (i.e. with key starting with `@`), it'll be flattened as a regular object without `@` prefixes. */ attributes?: boolean;
    /** If node only contains a `#text` value, it'll be flattened as a string (defaults to `true`). */ text?: boolean;
    /** If node does not contains any attribute or text, it'll be flattened to `null` (defaults to `true`). */ empty?: boolean;
  };
  /** Revive result. */ revive?: {
    /**
     * Trim texts (this is applied before other revivals, defaults to `true`).
     * It honors `xml:space="preserve"` attribute.
     */ trim?: boolean;
    /**
     * Revive XML entities (defaults to `true`).
     * Automatically unescape XML entities and replace common entities with their respective characters.
     */ entities?: boolean;
    /** Revive booleans (matching `/^(?:[Tt]rue|[Ff]alse)$/`).*/ booleans?: boolean;
    /**
     * Revive finite numbers.
     * Note that the version of the XML prolog is always treated as a string to avoid breaking documents.
     */ numbers?: boolean;
    /**
     * Custom reviver (this is applied after other revivals).
     * When it is applied on an attribute, `key` and `value` will be given.
     * When it is applied on a node, both `key` and `value` will be `null`.
     * Return `undefined` to delete either the attribute or the tag.
     */ custom?: (args: {
      name: string;
      key: Nullable<string>;
      value: Nullable<string>;
      node: Readonly<xml_node>;
    }) => unknown;
  };
  /**
   * Parsing mode.
   * Using `html` is more permissive and will not throw on some invalid XML syntax.
   * Mainly unquoted attributes will be supported and not properly closed tags will be accepted.
   */ mode?: "xml" | "html";
};
/**
 * Parse a XML string into an object.
 *
 * Output (cleaning, flattening, reviving, etc.) can be customized using the {@link options} parameter.
 *
 * Unless flattened, output nodes will contain the following non-enumerable properties (which mean they're not "visible" when iterating over, but are still explicitely accessible):
 * - General properties
 *   - `readonly ["~name"]: string`: tag name
 *   - `readonly ["~parent"]: xml_node|null`: parent node
 *   - `["#text"]?: string`: text content
 * - Node properties
 *   - `readonly ["~children"]: Array<xml_node|xml_text>`: node children
 *   - `readonly ["#comments"]?: Array<string>`: node comments
 *   - `readonly ["#text"]?: string`: concatenated children text content, this property becomes enumerable if at least one non-empty text node is present
 * - XML document properties
 *  - `["#doctype"]?: xml_node`: XML doctype
 *  - `["#instructions"]?: { [key:string]: xml_node| Array<xml_node> }`: XML processing instructions
 *
 * Attributes are prefixed with an arobase (`@`).
 *
 * You can also pass an object that implement {@link ReaderSync} instead of a string.
 *
 * ```ts
 * import { parse } from "./parse.ts"
 *
 * console.log(parse(
 * `
 *   <root>
 *     <!-- This is a comment -->
 *     <text>hello</text>
 *     <array>world</array>
 *     <array>monde</array>
 *     <array>‰∏ñÁïå</array>
 *     <array>üåè</array>
 *     <number>42</number>
 *     <boolean>true</boolean>
 *     <complex attribute="value">content</complex>
 *   </root>
 * `))
 * ```
 *
 * ```ts
 * import { parse } from "./parse.ts"
 * import { fromFileUrl } from "@std/path"
 *
 * using file = await Deno.open(fromFileUrl(import.meta.resolve("./bench/assets/small.xml")))
 * console.log(parse(file))
 * ```
 */ export declare function parse(content: string | ReaderSync, options?: options): xml_document;
/** Create a new text node. */ declare function xml_text(value: string, {}?: {
}): xml_text;
/** Create a new node. */ declare function xml_node(name: string, {}?: {
}): xml_node;
//# sourceMappingURL=parse.d.ts.map