/**
 * Stringify an XML document object into a XML string.
 * @module
 */ // Imports
/** Internal symbol to store properties without erasing user-provided ones. */ const internal = Symbol("internal");
/**
 * Stringify an {@link xml_document} object into a XML string.
 *
 * Output can be customized using the {@link options} parameter.
 *
 * ```ts
 * import { stringify } from "./stringify.ts"
 *
 * console.log(stringify({
 *   "@version": "1.0",
 *   "@standalone": "yes",
 *   root: {
 *     text: "hello",
 *     array: ["world", "monde", "ä¸–ç•Œ", "ðŸŒ"],
 *     number: 42,
 *     boolean: true,
 *     complex: {
 *       "@attribute": "value",
 *       "#text": "content",
 *     },
 *   }
 * }))
 * ```
 */ export function stringify(document, options) {
  options ??= {};
  options.format ??= {};
  options.format.indent ??= "  ";
  options.format.breakline ??= 128;
  const _options = options;
  let text = "";
  document = clone(document);
  // Add prolog
  text += xml_prolog(document, _options);
  // Add processing instructions
  if (document["#instructions"]) {
    for (const [name, nodes] of Object.entries(document["#instructions"])){
      for (const node of [
        nodes
      ].flat()){
        if (!("~name" in node)) {
          Object.defineProperties(node, {
            ["~name"]: {
              enumerable: false,
              writable: false,
              value: name
            }
          });
        }
        text += xml_instruction(node, _options);
      }
    }
  }
  // Add doctype
  if (document["#doctype"]) {
    text += xml_doctype(document["#doctype"], _options);
  }
  // Add root node
  const [root, ...garbage] = xml_children(document, _options);
  if (!root) {
    throw new SyntaxError("No root node detected");
  }
  if (garbage.length) {
    throw new SyntaxError("Multiple root node detected");
  }
  text += xml_node(root, {
    ..._options,
    depth: 0
  });
  return text.trim();
}
/**
 * Clone the provided user document so it {@linkcode stringify} can edit it in-place without affecting user.
 *
 * It copies all enumerable properties along non-enumerable one supported by `parse`
 */ function clone(document) {
  const cloned = Array.isArray(document) ? [] : {};
  for(const property in document){
    cloned[property] = document[property] !== null && [
      "object",
      "function"
    ].includes(typeof document[property]) ? clone(document[property]) : document[property];
  }
  ;
  [
    "~name",
    "~parent",
    "#text",
    "~children",
    "#comments",
    "#text",
    "#doctype",
    "#instructions",
    internal
  ].forEach((property)=>{
    if (property in document) {
      Object.defineProperty(cloned, property, Object.getOwnPropertyDescriptor(document, property));
    }
  });
  return cloned;
}
/**
 * Helper to create a CDATA node.
 *
 * ```ts
 * import { stringify, cdata } from "./stringify.ts"
 * stringify({ string: cdata(`hello <world>`) })
 * // <string><![CDATA[hello <world>]]></string>
 * ```
 */ export function cdata(text) {
  return {
    "~name": "~cdata",
    "#text": text
  };
}
/**
 * Helper to create a comment node.
 *
 * ```ts
 * import { stringify, comment } from "./stringify.ts"
 * stringify({ string: comment(`hello world`) })
 * // <string><!--hello world--></string>
 * ```
 */ export function comment(text) {
  return {
    "~name": "~comment",
    "#text": text
  };
}
/** Create XML prolog. */ function xml_prolog(document, options) {
  ;
  document["~name"] ??= "xml";
  return xml_instruction(document, options);
}
/** Create XML instruction. */ function xml_instruction(node, { format: { indent } }) {
  let text = "";
  const attributes = xml_attributes(node, arguments[1]);
  if (attributes.length) {
    text += `<?${node["~name"].replace(/^~/, "")}`;
    for (const [name, value] of attributes){
      text += ` ${name}="${value}"`;
    }
    text += `?>${indent ? "\n" : ""}`;
  }
  return text;
}
/** Create XML doctype. */ function xml_doctype(node, { format: { indent } }) {
  let text = "";
  const attributes = xml_attributes(node, arguments[1]);
  const elements = xml_children(node, arguments[1]);
  if (attributes.length + elements.length) {
    text += `<!DOCTYPE`;
    for (const [name] of attributes){
      text += ` ${!/^[A-Za-z0-9_]+$/.test(name) ? `"${name}"` : name}`;
    }
    if (elements.length) {
      text += `${indent ? `\n${indent}` : " "}[${indent ? "\n" : ""}`;
      for (const element of elements){
        text += `${indent}<!ELEMENT ${element["~name"]} (${element["#text"]})>${indent ? "\n" : ""}`;
      }
      text += `${indent ? indent : ""}]${indent ? "\n" : ""}`;
    }
    text += `>${indent ? "\n" : ""}`;
  }
  return text;
}
/** Create XML node. */ function xml_node(node, { format: { breakline = 0, indent = "" }, replace, depth = 0 }) {
  if (replace?.custom) {
    if (replace.custom({
      name: node["~name"],
      key: null,
      value: null,
      node
    }) === undefined) {
      return "";
    }
  }
  let text = `${indent.repeat(depth)}<${node["~name"]}`;
  const attributes = xml_attributes(node, arguments[1]);
  const children = xml_children(node, arguments[1]);
  const preserve = node["@xml:space"] === "preserve";
  for (const [name, value] of attributes){
    text += ` ${name}="${value}"`;
  }
  if (children.length || "#text" in node && node["#text"].length) {
    const inline = indent && !preserve && (children.length || node["#text"].length > breakline - indent.length * depth);
    text += `>${indent && !preserve && children.length ? "\n" : ""}`;
    if ("#text" in node) {
      if (inline) {
        text += `\n${indent.repeat(depth + 1)}`;
      }
      text += node["#text"];
      if (inline) {
        text += "\n";
      }
    }
    for (const child of children){
      text += xml_node(child, {
        ...arguments[1],
        depth: depth + 1
      });
    }
    if (inline) {
      text += indent.repeat(depth);
    }
    text += `</${node["~name"]}>${indent ? "\n" : ""}`;
  } else {
    text += `/>${indent ? "\n" : ""}`;
  }
  return text;
}
/** Extract children from node. */ function xml_children(node, options) {
  const children = Object.keys(node).filter((key)=>/^[A-Za-z_]/.test(key)).flatMap((key)=>[
      node[key]
    ].flat().map((value)=>{
      switch(true){
        case value === null:
          return {
            ["~name"]: key,
            ["#text"]: ""
          };
        case typeof value === "object":
          {
            const child = {
              ...value,
              ["~name"]: key
            };
            if (value["~name"]?.startsWith("~")) {
              child[internal] = value["~name"];
            }
            return child;
          }
        default:
          return {
            ["~name"]: key,
            ["#text"]: `${value}`
          };
      }
    })).map((node)=>{
    if ("#text" in node) {
      const cdata = node[internal] === "~cdata";
      const comment = node[internal] === "~comment";
      node["#text"] = replace(node, "#text", {
        ...options,
        escape: cdata ? [] : [
          "&",
          "<",
          ">"
        ]
      });
      if (node["#text"] === undefined) {
        delete node["#text"];
      } else {
        node["#text"] = cdata ? `<![CDATA[${node["#text"]}]]>` : comment ? `<!--${node["#text"]}-->` : `${node["#text"]}`;
      }
    }
    return node;
  });
  return children;
}
/** Extract attributes from node. */ function xml_attributes(node, options) {
  return Object.entries(node).filter(([key])=>key.startsWith("@")).map(([key])=>[
      key.slice(1),
      replace(node, key, {
        ...options,
        escape: [
          "&",
          '"',
          "'"
        ]
      })
    ]).filter(([_, value])=>value !== undefined);
}
/** Entities */ const entities = {
  "&": "&amp;",
  '"': "&quot;",
  "<": "&lt;",
  ">": "&gt;",
  "'": "&apos;"
};
/** Replace value. */ function replace(node, key, options) {
  let value = `${node[key]}`;
  if (options?.escape) {
    if (options?.replace?.entities) {
      options.escape = Object.keys(entities);
    }
    for (const char of options?.escape){
      value = `${value}`.replaceAll(char, entities[char]);
    }
  }
  if (options?.replace?.custom) {
    return options.replace.custom({
      name: node["~name"],
      key,
      value,
      node: node
    });
  }
  return value;
}
//# sourceMappingURL=stringify.js.map