// Copyright 2018-2025 the Deno authors. MIT license.
import { getNodeFs, getNodeUtil, isDeno } from "./_utils.js";
import { getOpenFsFlag } from "./_get_fs_flag.js";
import { mapError } from "./_map_error.js";
import { NodeFsFile } from "./_node_fs_file.js";
/**
 * Open a file and resolve to an instance of {@linkcode FsFile}. The file
 * does not need to previously exist if using the `create` or `createNew` open
 * options. The caller may have the resulting file automatically closed by the
 * runtime once it's out of scope by declaring the file variable with the
 * `using` keyword.
 *
 * Requires `allow-read` and/or `allow-write` permissions depending on
 * options.
 *
 * @example Automatic closing a file with `using` **TypeScript Only**
 * ```ts ignore
 * import { open } from "@std/fs/unstable-open";
 * using file = await open("/foo/bar.txt", { read: true, write: true });
 * // Do work with file.
 * ```
 *
 * @example Manually closing a file
 * ```ts ignore
 * import { open } from "@std/fs/unstable-open";
 * const file = await open("/foo/bar.txt", { read: true, write: true });
 * // Do work with file.
 * file.close();
 * ```
 *
 * @tags allow-read, allow-write
 *
 * @param path The path to the opened file.
 * @param options Options to open a file. See {@linkcode OpenOptions}.
 * @returns A Promise that resolves to a {@linkcode FsFile} instance.
 */ export async function open(path, options) {
  if (isDeno) {
    return Deno.open(path, options);
  } else {
    const { read = true, write = false, append = false, truncate = false, create = false, createNew = false, mode = 0o666 } = options ?? {};
    try {
      const flag = getOpenFsFlag({
        read,
        write,
        append,
        truncate,
        create,
        createNew
      });
      const { open } = getNodeFs();
      const { promisify } = getNodeUtil();
      const nodeOpenFd = promisify(open);
      const fd = await nodeOpenFd(path, flag, mode);
      return new NodeFsFile(fd);
    } catch (error) {
      throw mapError(error);
    }
  }
}
/**
 * Synchronously open a file and return an instance of {@linkcode FsFile}.
 * The file does not need to previously exist if using the `create` or
 * `createNew` open options. The caller may have the resulting file
 * automatically closed by the runtime once it's out of scope by declaring the
 * file variable with the `using` keyword.
 *
 * Requires `allow-read` and/or `allow-write` permissions depending on
 * options.
 *
 * @example Automatic closing a file with `using` **TypeScript Only**
 * ```ts ignore
 * import { openSync } from "@std/fs/unstable-open";
 * using file = openSync("/foo/bar.txt", { read: true, write: true });
 * // Do work with file.
 * ```
 *
 * @example Manually closing an opened file
 * ```ts ignore
 * import { openSync } from "@std/fs/unstable-open";
 * const file = openSync("/foo/bar.txt", { read: true, write: true });
 * // Do work with file.
 * file.close();
 * ```
 *
 * @tags allow-read, allow-write
 *
 * @param path The path to the opened file.
 * @param options Options to open a file. See {@linkcode OpenOptions}.
 * @returns A {@linkcode FsFile} instance.
 */ export function openSync(path, options) {
  if (isDeno) {
    return Deno.openSync(path, options);
  } else {
    const { read = true, write = false, append = false, truncate = false, create = false, createNew = false, mode = 0o666 } = options ?? {};
    try {
      const flag = getOpenFsFlag({
        read,
        write,
        append,
        truncate,
        create,
        createNew
      });
      const fd = getNodeFs().openSync(path, flag, mode);
      return new NodeFsFile(fd);
    } catch (error) {
      throw mapError(error);
    }
  }
}
//# sourceMappingURL=unstable_open.js.map