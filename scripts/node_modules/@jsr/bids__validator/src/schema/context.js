import { FileTree } from "../types/filetree.js";
import { ColumnsMap } from "../types/columns.js";
import { readEntities } from "./entities.js";
import { findDatatype } from "./datatypes.js";
import { DatasetIssues } from "../issues/datasetIssues.js";
import { readSidecars } from "../files/inheritance.js";
import { parseGzip } from "../files/gzip.js";
import { loadTSV, loadTSVGZ } from "../files/tsv.js";
import { parseTIFF } from "../files/tiff.js";
import { loadJSON } from "../files/json.js";
import { loadHeader } from "../files/nifti.js";
import { buildAssociations } from "./associations.js";
import { logger } from "../utils/logger.js";
export class BIDSContextDataset {
  #dataset_description = {};
  tree;
  ignored;
  datatypes;
  modalities;
  subjects;
  issues;
  sidecarKeyValidated;
  options;
  schema;
  pseudofileExtensions;
  opaqueDirectories;
  // Opaque object for HED validator
  hedSchemas = undefined;
  constructor(args){
    this.schema = args.schema || {};
    this.dataset_description = args.dataset_description || {};
    this.tree = args.tree || new FileTree('/unknown', 'unknown');
    this.ignored = args.ignored || [];
    this.datatypes = args.datatypes || [];
    this.modalities = args.modalities || [];
    this.sidecarKeyValidated = new Set();
    if (args.options) {
      this.options = args.options;
    }
    this.issues = args.issues || new DatasetIssues();
    this.pseudofileExtensions = new Set(args.schema ? Object.values(this.schema.objects.extensions)?.map((ext)=>ext.value)?.filter((ext)=>ext.endsWith('/')) : []);
    this.opaqueDirectories = new Set(args.schema ? Object.values(this.schema.rules.directories.raw)?.filter((rule)=>rule?.opaque && 'name' in rule)?.map((dir)=>`/${dir.name}`) : []);
    // @ts-ignore
    this.subjects = args.subjects || null;
  }
  get dataset_description() {
    return this.#dataset_description;
  }
  set dataset_description(value) {
    this.#dataset_description = value;
    if (!this.dataset_description.DatasetType) {
      this.dataset_description.DatasetType = this.dataset_description.GeneratedBy ? 'derivative' : 'raw';
    }
  }
  isPseudoFile(file) {
    const { suffix, extension, entities } = readEntities(file.name);
    return suffix !== '' && Object.keys(entities).length > 0 && this.pseudofileExtensions.has(`${extension}/`);
  }
  isOpaqueDirectory(file) {
    return this.opaqueDirectories.has(file.path);
  }
}
class BIDSContextDatasetSubjects {
  sub_dirs;
  participant_id;
  phenotype;
  constructor(sub_dirs, participant_id, phenotype){
    this.sub_dirs = sub_dirs ? sub_dirs : [];
    this.participant_id = participant_id;
    this.phenotype = phenotype;
  }
}
export class BIDSContext {
  dataset;
  subject;
  // path: string  <- getter
  // size: number  <- getter
  entities;
  datatype;
  suffix;
  extension;
  modality;
  sidecar;
  associations;
  columns;
  json;
  gzip;
  nifti_header;
  ome;
  tiff;
  directory;
  file;
  filenameRules;
  sidecarKeyOrigin;
  loaded;
  constructor(file, dsContext, fileTree){
    this.dataset = dsContext ? dsContext : new BIDSContextDataset({
      tree: fileTree
    });
    this.filenameRules = [];
    this.file = file;
    const { entities, suffix, extension } = readEntities(file.name);
    const { datatype, modality } = findDatatype(file, this.dataset.schema);
    this.entities = entities;
    this.suffix = suffix;
    this.extension = extension;
    this.datatype = datatype;
    this.modality = modality;
    this.subject = {};
    this.sidecar = {};
    this.sidecarKeyOrigin = {};
    this.columns = new ColumnsMap();
    this.json = {};
    this.associations = {};
    this.loaded = this.asyncLoads();
  }
  get schema() {
    return this.dataset.schema;
  }
  get size() {
    return this.file.size;
  }
  get path() {
    return this.file.path;
  }
  /**
   * Implementation specific absolute path for the dataset root
   *
   * In the browser, this is always at the root
   */ get datasetPath() {
    return this.dataset.tree.path;
  }
  /**
   * Walks the fileTree backwards from the current file to the root,
   * loading any valid json sidecars found.
   * Earlier (deeper) sidecars take precedence over later ones.
   */ async loadSidecar() {
    if (this.extension === '.json') {
      return;
    }
    let sidecars;
    try {
      sidecars = await readSidecars(this.file);
    } catch (error) {
      if (error?.code) {
        this.dataset.issues.add(error);
        return;
      } else {
        throw error;
      }
    }
    for (const [path, json] of sidecars.entries()){
      const overrides = Object.keys(this.sidecar).filter((x)=>Object.hasOwn(json, x));
      for (const key of overrides){
        if (json[key] !== this.sidecar[key]) {
          const overrideLocation = this.sidecarKeyOrigin[key];
          this.dataset.issues.add({
            code: 'SIDECAR_FIELD_OVERRIDE',
            subCode: key,
            location: overrideLocation,
            issueMessage: `Sidecar key defined in ${path} overrides previous value (${json[key]}) from ${overrideLocation}`
          });
        }
      }
      this.sidecar = {
        ...json,
        ...this.sidecar
      };
      Object.keys(json).map((x)=>this.sidecarKeyOrigin[x] ??= path);
    }
    // Hack: round RepetitionTime to 3 decimal places; schema should add rounding function
    if (typeof this.sidecar.RepetitionTime === 'number') {
      this.sidecar.RepetitionTime = Math.round(this.sidecar.RepetitionTime * 1000) / 1000;
    }
  }
  async loadNiftiHeader() {
    if (!this.extension.startsWith('.nii') || this.dataset?.options?.ignoreNiftiHeaders) return;
    this.nifti_header = await loadHeader(this.file).catch((error)=>{
      if (error.code) {
        this.dataset.issues.add({
          ...error,
          location: this.file.path
        });
        return undefined;
      } else {
        throw error;
      }
    });
  }
  async loadColumns() {
    if (this.extension == '.tsv') {
      this.columns = await loadTSV(this.file, this.dataset.options?.maxRows).catch((error)=>{
        if (error.code) {
          this.dataset.issues.add({
            ...error,
            location: this.file.path
          });
        }
        logger.warn(`tsv file could not be opened by loadColumns '${this.file.path}'`);
        logger.debug(error);
        return new Map();
      });
    } else if (this.extension == '.tsv.gz') {
      const headers = this.sidecar.Columns;
      if (!headers || this.size === 0) {
        // Missing Columns will be caught by sidecar rules
        // Note that these rules currently select for suffix, and will need to be generalized
        // or duplicated for new .tsv.gz files
        // `this.size === 0` will show as `EMPTY_FILE`, so do not add INVALID_GZIP
        return;
      }
      this.columns = await loadTSVGZ(this.file, headers, this.dataset.options?.maxRows).catch((error)=>{
        if (error.code) {
          this.dataset.issues.add({
            ...error,
            location: this.file.path
          });
        }
        logger.warn(`tsv.gz file could not be opened by loadColumns '${this.file.path}'`);
        logger.debug(error);
        return new Map();
      });
    }
    return;
  }
  async loadAssociations() {
    this.associations = await buildAssociations(this);
    return;
  }
  async loadJSON() {
    if (this.extension !== '.json') {
      return;
    }
    this.json = await loadJSON(this.file).catch((error)=>{
      if (error.code) {
        this.dataset.issues.add({
          ...error,
          location: this.file.path
        });
        return {};
      } else {
        throw error;
      }
    });
  }
  async loadGzip() {
    if (!this.extension.endsWith('.gz')) {
      return;
    }
    this.gzip = await parseGzip(this.file, 512).catch((error)=>{
      logger.debug('Error parsing gzip header', error);
      return undefined;
    });
  }
  async loadTIFF() {
    if (!this.extension.endsWith('.tif') && !this.extension.endsWith('.btf')) {
      return;
    }
    const { tiff, ome } = await parseTIFF(this.file, this.extension.startsWith('.ome')).catch((error)=>{
      logger.debug('Error parsing tiff header', error);
      return {
        tiff: undefined,
        ome: undefined
      };
    });
    this.tiff = tiff;
    this.ome = ome;
  }
  // This is currently done for every file. It should be done once for the dataset.
  async loadSubjects() {
    if (this.dataset.subjects != null) {
      return;
    }
    this.dataset.subjects = new BIDSContextDatasetSubjects();
    // Load subject dirs from the file tree
    this.dataset.subjects.sub_dirs = this.dataset.tree.directories.filter((dir)=>dir.name.startsWith('sub-')).map((dir)=>dir.name);
    // Load participants from participants.tsv
    const participants_tsv = this.dataset.tree.get('participants.tsv');
    if (participants_tsv) {
      const participantsData = await loadTSV(participants_tsv).catch((error)=>{
        return new Map();
      });
      this.dataset.subjects.participant_id = participantsData['participant_id'];
    }
  }
  async asyncLoads() {
    // loaders that may be depended on by other loaders
    const initial = [
      this.loadSidecar(),
      this.loadAssociations()
    ];
    // loaders that do not depend on other loaders
    const independent = [
      this.loadSubjects(),
      this.loadNiftiHeader(),
      this.loadJSON(),
      this.loadGzip(),
      this.loadTIFF()
    ];
    // Loaders with dependencies
    await Promise.allSettled(initial);
    await this.loadColumns();
    await Promise.allSettled(independent);
  }
}
//# sourceMappingURL=context.js.map