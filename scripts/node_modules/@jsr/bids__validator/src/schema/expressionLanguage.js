import { memoize } from "../utils/memoize.js";
function exists(list, rule = 'dataset') {
  if (list == null) {
    return 0;
  }
  const prefix = [];
  const fileTree = rule == 'file' ? this.file.parent : this.dataset.tree;
  // Stimuli and subject-relative paths get prefixes
  if (rule == 'stimuli') {
    prefix.push('stimuli');
  } else if (rule == 'subject') {
    prefix.push('sub-' + this.entities.sub);
  }
  if (!Array.isArray(list)) {
    list = [
      list
    ];
  }
  if (rule == 'bids-uri') {
    return list.filter((x)=>{
      // XXX To implement
      if (x.startsWith('bids:')) {
        return true;
      }
      return false;
    }).length;
  } else {
    // dataset, subject and stimuli
    return list.filter((x)=>{
      const parts = prefix.concat(x.split('/'));
      return fileTree.contains(parts);
    }).length;
  }
}
export const expressionFunctions = {
  index: (list, item)=>{
    const index = list.indexOf(item);
    return index != -1 ? index : null;
  },
  intersects: (a, b)=>{
    // Tolerate single values
    if (!Array.isArray(a)) {
      a = [
        a
      ];
    }
    if (!Array.isArray(b)) {
      b = [
        b
      ];
    }
    // Construct a set from the smaller list
    if (a.length < b.length) {
      const tmp = a;
      a = b;
      b = tmp;
    }
    if (b.length === 0) {
      return false;
    }
    const bSet = new Set(b);
    const intersection = a.filter((x)=>bSet.has(x));
    if (intersection.length === 0) {
      return false;
    }
    return intersection;
  },
  match: (target, regex)=>{
    const re = RegExp(regex);
    return target.match(re) !== null;
  },
  type: (operand)=>{
    if (Array.isArray(operand)) {
      return 'array';
    }
    if (typeof operand === 'undefined' || operand === null) {
      return 'null';
    }
    return typeof operand;
  },
  min: (list)=>{
    return list != null ? Math.min(...list.map(Number).filter((x)=>!isNaN(x))) : null;
  },
  max: (list)=>{
    return list != null ? Math.max(...list.map(Number).filter((x)=>!isNaN(x))) : null;
  },
  length: (list)=>{
    if (Array.isArray(list) || typeof list == 'string') {
      return list.length;
    }
    return null;
  },
  unique: (list)=>{
    if (list !== null) {
      return [
        ...new Set(list)
      ];
    }
    return null;
  },
  count: (list, val)=>{
    return list.filter((x)=>x === val).length;
  },
  exists: exists,
  substr: (arg, start, end)=>{
    if (arg == null || start == null || end == null) {
      return null;
    }
    return arg.substr(start, end - start);
  },
  sorted: (list, method = 'auto')=>{
    const cmp = {
      numeric: (a, b)=>{
        return Number(a) - Number(b);
      },
      lexical: (a, b)=>{
        return String(a).localeCompare(String(b));
      },
      auto: (a, b)=>{
        return +(a > b) - +(a < b);
      }
    }[method];
    return list.toSorted(cmp);
  },
  allequal: (a, b)=>{
    return a != null && b != null && a.length === b.length && a.every((v, i)=>v === b[i]);
  }
};
/**
 * Generate a function that evaluates an expression using the BIDS context.
 */ function _contextFunction(expr) {
  return new Function('context', `with (context) { return ${expr.replace(/\\/g, '\\\\')} }`);
}
/**
 * Generate a function that evaluates an expression using the BIDS context.
 */ export const contextFunction = memoize(_contextFunction);
function _formatter(format) {
  if (!format.includes('{')) {
    return (context)=>format;
  }
  const template = format.replace(/{/g, '${').replace(/\\/g, '\\\\').replace(/`/g, '\\`');
  return new Function('context', `with (context) { return \`${template}\` }`);
}
/**
 * Generate a function that formats a string using the BIDS context.
 *
 * Strings are expected to use Python-style formatting,
 * e.g., "sub-{entities.sub}/ses-{entities.ses}".
 */ export const formatter = memoize(_formatter);
function safeContext(context) {
  return new Proxy(context, {
    has: ()=>true,
    get: (target, prop)=>prop === Symbol.unscopables ? undefined : target[prop]
  });
}
export function prepareContext(context) {
  Object.assign(context, expressionFunctions);
  // @ts-expect-error
  context.exists.bind(context);
  return safeContext(context);
}
//# sourceMappingURL=expressionLanguage.js.map