import { BIDSContext } from "./context.js";
import { BIDSFile } from "../types/filetree.js";
import { loadTSV } from "../files/tsv.js";
import { loadJSON } from "../files/json.js";
import { queuedAsyncIterator } from "../utils/queue.js";
function* quickWalk(dir) {
  for (const file of dir.files){
    yield file;
  }
  for (const subdir of dir.directories){
    yield* quickWalk(subdir);
  }
}
class NullFileOpener {
  size;
  constructor(size = 0){
    this.size = size;
  }
  stream = async ()=>new ReadableStream({
      start (controller) {
        controller.close();
      }
    });
  text = async ()=>'';
  readBytes = async (size, offset)=>new Uint8Array();
}
function pseudoFile(dir, opaque) {
  return new BIDSFile(// Use a trailing slash to indicate directory
  `${dir.path}/`, new NullFileOpener(opaque ? [
    ...quickWalk(dir)
  ].reduce((acc, file)=>acc + file.size, 0) : 0), dir.ignored, dir.parent);
}
/** Recursive algorithm for visiting each file in the dataset, creating a context */ async function* _walkFileTree(fileTree, dsContext) {
  for (const file of fileTree.files){
    if (file.ignored) {
      continue;
    }
    yield new BIDSContext(file, dsContext);
  }
  for (const dir of fileTree.directories){
    if (dir.ignored) {
      continue;
    }
    const pseudo = dsContext.isPseudoFile(dir);
    const opaque = pseudo || dsContext.isOpaqueDirectory(dir);
    const context = new BIDSContext(pseudoFile(dir, opaque), dsContext);
    context.directory = !pseudo;
    yield context;
    if (!opaque) {
      yield* _walkFileTree(dir, dsContext);
    }
  }
  yield ()=>{
    loadTSV.cache.delete(fileTree.path);
    loadJSON.cache.delete(fileTree.path);
  };
}
/** Walk all files in the dataset and construct a context for each one */ export async function* walkFileTree(dsContext, bufferSize = 1) {
  for await (const context of queuedAsyncIterator(_walkFileTree(dsContext.tree, dsContext), bufferSize)){
    await context.loaded;
    yield context;
  }
}
//# sourceMappingURL=walk.js.map