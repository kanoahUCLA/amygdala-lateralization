import { loadJSON } from "../files/json.js";
import { loadTSV } from "../files/tsv.js";
import { parseBvalBvec } from "../files/dwi.js";
import { readSidecars, walkBack } from "../files/inheritance.js";
import { evalCheck } from "./applyRules.js";
import { expressionFunctions } from "./expressionLanguage.js";
import { readEntities } from "./entities.js";
import { readText } from "../files/access.js";
function defaultAssociation(file, _options) {
  return Promise.resolve({
    path: file.path
  });
}
async function constructSidecar(file) {
  const sidecars = await readSidecars(file);
  // Note ordering here gives precedence to the more specific sidecar
  return sidecars.values().reduce((acc, json)=>({
      ...json,
      ...acc
    }), {});
}
/**
 * This object describes lookup functions for files associated to data files in a bids dataset.
 * For any given data file we iterate over the associations defined schema.meta.associations.
 * If the selectors match the data file, we attempt to find an associated file,
 * and use the given function to load the data from that file.
 *
 * Many associations only consist of a path; this object is for more complex associations.
 */ const associationLookup = {
  events: async (file, options)=>{
    const columns = await loadTSV(file, options.maxRows).catch((e)=>{
      return new Map();
    });
    return {
      path: file.path,
      onset: columns.get('onset') || [],
      sidecar: await constructSidecar(file)
    };
  },
  aslcontext: async (file, options)=>{
    const columns = await loadTSV(file, options.maxRows).catch((e)=>{
      return new Map();
    });
    return {
      path: file.path,
      n_rows: columns.get('volume_type')?.length || 0,
      volume_type: columns.get('volume_type') || []
    };
  },
  bval: async (file, options)=>{
    const contents = await readText(file);
    const rows = parseBvalBvec(contents);
    return {
      path: file.path,
      n_cols: rows ? rows[0].length : 0,
      n_rows: rows ? rows.length : 0,
      // @ts-expect-error values is expected to be a number[], coerce lazily
      values: rows[0]
    };
  },
  bvec: async (file, options)=>{
    const contents = await readText(file);
    const rows = parseBvalBvec(contents);
    if (rows.some((row)=>row.length !== rows[0].length)) {
      throw {
        key: 'BVEC_ROW_LENGTH'
      };
    }
    return {
      path: file.path,
      n_cols: rows ? rows[0].length : 0,
      n_rows: rows ? rows.length : 0
    };
  },
  channels: async (file, options)=>{
    const columns = await loadTSV(file, options.maxRows).catch((e)=>{
      return new Map();
    });
    return {
      path: file.path,
      type: columns.get('type'),
      short_channel: columns.get('short_channel'),
      sampling_frequency: columns.get('sampling_frequency')
    };
  },
  physio: async (file, options)=>{
    return {
      path: file.path,
      sidecar: await constructSidecar(file)
    };
  }
};
const multiAssociationLookup = {
  coordsystems: async (files, options)=>{
    const jsons = await Promise.allSettled(files.map((f)=>loadJSON(f).catch(()=>({}))));
    const parents = jsons.map((j)=>j.status === 'fulfilled' ? j.value?.ParentCoordinateSystem : undefined).filter((p)=>p);
    return {
      paths: files.map((f)=>f.path),
      spaces: files.map((f)=>readEntities(f.name).entities?.space),
      ParentCoordinateSystems: parents
    };
  }
};
export async function buildAssociations(context) {
  const associations = {};
  const schema = context.dataset.schema;
  Object.assign(context, expressionFunctions);
  // @ts-expect-error
  context.exists.bind(context);
  for (const [key, rule] of Object.entries(schema.meta.associations)){
    if (!rule.selectors.every((x)=>evalCheck(x, context))) {
      continue;
    }
    let file;
    let extension = [];
    if (typeof rule.target.extension === 'string') {
      extension = [
        rule.target.extension
      ];
    } else if (Array.isArray(rule.target.extension)) {
      extension = rule.target.extension;
    }
    try {
      file = walkBack(context.file, rule.inherit, extension, rule.target.suffix, rule.target?.entities ?? []).next().value;
    } catch (error) {
      if (error?.code === 'MULTIPLE_INHERITABLE_FILES') {
        context.dataset.issues.add(error);
        continue;
      } else {
        throw error;
      }
    }
    if (file && !(Array.isArray(file) && file.length === 0)) {
      const options = {
        maxRows: context.dataset.options?.maxRows
      };
      if (key in multiAssociationLookup) {
        const load = multiAssociationLookup[key];
        if (!Array.isArray(file)) {
          file = [
            file
          ];
        }
        associations[key] = await load(file, options).catch((e)=>{});
      } else {
        const load = associationLookup[key] ?? defaultAssociation;
        if (Array.isArray(file)) {
          file = file[0];
        }
        const location = file.path;
        associations[key] = await load(file, options).catch((error)=>{
          if (error.code) {
            context.dataset.issues.add({
              ...error,
              location
            });
          }
        });
      }
    }
  }
  return Promise.resolve(associations);
}
//# sourceMappingURL=associations.js.map