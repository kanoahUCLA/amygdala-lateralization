export async function* bufferAsyncIterator(asyncIterator, bufferSize = 5) {
  const iterator = asyncIterator[Symbol.asyncIterator]();
  const promises = [];
  // Initialize buffer
  for(let i = 0; i < bufferSize; i++){
    promises.push(iterator.next());
  }
  while(promises.length > 0){
    const result = await promises.shift();
    if (!result.done) {
      yield result.value;
      // Keep buffer full
      promises.push(iterator.next());
    }
  }
}
export async function* cleanupAsyncIterator(asyncIterator) {
  for await (const item of asyncIterator){
    if (typeof item === 'function') {
      item();
    } else {
      yield item;
    }
  }
}
export async function* queuedAsyncIterator(asyncIterator, bufferSize = 5) {
  yield* cleanupAsyncIterator(bufferAsyncIterator(asyncIterator, bufferSize));
}
//# sourceMappingURL=queue.js.map