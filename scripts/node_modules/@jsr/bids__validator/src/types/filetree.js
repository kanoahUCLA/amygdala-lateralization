import { basename } from "@jsr/std__path";
import { FileIgnoreRules } from "../files/ignore.js";
export class BIDSFile {
  name;
  path;
  #parent;
  viewed = false;
  #ignore;
  opener;
  constructor(path, opener, ignore, parent){
    this.path = path;
    this.name = basename(path);
    if (this.path.endsWith('/')) {
      this.name = `${this.name}/`;
    }
    this.#ignore = ignore ?? false;
    this.opener = opener;
    this.parent = parent ?? new FileTree('', '/', undefined);
  }
  get parent() {
    return this.#parent.deref();
  }
  set parent(tree) {
    this.#parent = new WeakRef(tree);
  }
  get ignored() {
    if (typeof this.#ignore === 'boolean') return this.#ignore;
    return this.#ignore.test(this.path);
  }
  get size() {
    return this.opener.size;
  }
  async text() {
    return this.opener.text();
  }
  async readBytes(size, offset = 0) {
    return this.opener.readBytes(size, offset);
  }
  async stream() {
    return this.opener.stream();
  }
}
/**
 * Abstract FileTree for all environments (Deno, Browser, Python)
 */ export class FileTree {
  // Relative path to this FileTree location
  path;
  // Name of this directory level
  name;
  files;
  directories;
  viewed = false;
  #parent;
  #ignore;
  constructor(path, name, parent, ignore){
    this.path = path;
    this.files = [];
    this.directories = [];
    this.name = name;
    this.parent = parent;
    this.#ignore = ignore ?? new FileIgnoreRules([]);
  }
  get parent() {
    return this.#parent?.deref();
  }
  set parent(tree) {
    this.#parent = tree ? new WeakRef(tree) : undefined;
  }
  get ignored() {
    if (!this.parent) return false;
    return this.#ignore.test(this.path);
  }
  _get(parts) {
    if (parts.length === 0) {
      return undefined;
    } else if (parts.length === 1) {
      return this.files.find((x)=>x.name === parts[0]) || this.directories.find((x)=>x.name === parts[0]);
    } else {
      const nextDir = this.directories.find((x)=>x.name === parts[0]);
      return nextDir?._get(parts.slice(1, parts.length));
    }
  }
  get(path) {
    if (path.startsWith('/')) {
      path = path.slice(1);
    }
    return this._get(path.split('/'));
  }
  contains(parts) {
    const value = this._get(parts);
    return value ? value.viewed = true : false;
  }
}
//# sourceMappingURL=filetree.js.map