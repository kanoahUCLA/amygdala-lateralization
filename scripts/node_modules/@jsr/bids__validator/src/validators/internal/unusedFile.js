function* walkFileTree(fileTree, dsContext) {
  if (!fileTree) {
    return;
  }
  for (const file of fileTree.files){
    if (!file.ignored) {
      yield file;
    }
  }
  for (const dir of fileTree.directories){
    if (!dir.ignored && !dsContext.isPseudoFile(dir) && !dsContext.isOpaqueDirectory(dir)) {
      yield* walkFileTree(dir, dsContext);
    }
  }
}
export async function unusedStimulus(schema, dsContext) {
  const stimDir = dsContext.tree.get('stimuli');
  const unusedStimuli = [
    ...walkFileTree(stimDir, dsContext)
  ].filter((stimulus)=>!stimulus.viewed);
  if (unusedStimuli.length) {
    dsContext.issues.add({
      code: 'UNUSED_STIMULUS',
      affects: unusedStimuli.map((s)=>s.path)
    });
  }
}
const standalone_json = [
  'dataset_description.json',
  'genetic_info.json'
];
export async function sidecarWithoutDatafile(schema, dsContext) {
  const unusedSidecars = [
    ...walkFileTree(dsContext.tree, dsContext)
  ].filter((file)=>!file.viewed && file.name.endsWith('.json') && !standalone_json.includes(file.name));
  unusedSidecars.forEach((sidecar)=>{
    dsContext.issues.add({
      code: 'SIDECAR_WITHOUT_DATAFILE',
      location: sidecar.path
    });
  });
}
//# sourceMappingURL=unusedFile.js.map