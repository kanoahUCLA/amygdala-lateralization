import { loadJSON } from "../files/json.js";
import { applyRules } from "../schema/applyRules.js";
import { walkFileTree } from "../schema/walk.js";
import { loadSchema } from "../setup/loadSchema.js";
import { Summary } from "../summary/summary.js";
import { filenameCase } from "./filenameCase.js";
import { filenameIdentify } from "./filenameIdentify.js";
import { filenameValidate } from "./filenameValidate.js";
import { emptyFile } from "./internal/emptyFile.js";
import { sidecarWithoutDatafile, unusedStimulus } from "./internal/unusedFile.js";
import { BIDSContextDataset } from "../schema/context.js";
import { hedValidate } from "./hed.js";
import { citationValidate } from "./citation.js";
import { logger } from "../utils/logger.js";
/**
 * Ordering of checks to apply
 */ const perContextChecks = [
  emptyFile,
  filenameIdentify,
  filenameValidate,
  filenameCase,
  applyRules,
  hedValidate
];
const perDSChecks = [
  unusedStimulus,
  sidecarWithoutDatafile,
  citationValidate
];
/**
 * Full BIDS schema validation entrypoint
 */ export async function validate(fileTree, options, config) {
  const summary = new Summary();
  const schema = await loadSchema(options.schema);
  summary.schemaVersion = schema.schema_version;
  /* There should be a dataset_description in root, this will tell us if we
   * are dealing with a derivative dataset
   */ const ddFile = fileTree.get('dataset_description.json');
  const dsContext = new BIDSContextDataset({
    options,
    schema,
    tree: fileTree
  });
  if (ddFile) {
    dsContext.dataset_description = await loadJSON(ddFile).catch((error)=>{
      if (error.code) {
        dsContext.issues.add({
          ...error,
          location: ddFile.path
        });
        return {};
      } else {
        throw error;
      }
    });
    summary.dataProcessed = dsContext.dataset_description.DatasetType === 'derivative';
  } else {
    dsContext.issues.add({
      code: 'MISSING_DATASET_DESCRIPTION',
      affects: [
        '/dataset_description.json'
      ]
    });
  }
  // Empty list defaults to allow all
  if (options.datasetTypes?.length) {
    const datasetType = dsContext.dataset_description.DatasetType ?? 'raw';
    if (!options.datasetTypes.includes(datasetType)) {
      dsContext.issues.add({
        code: 'UNSUPPORTED_DATASET_TYPE',
        location: '/dataset_description.json',
        issueMessage: `"DatasetType": "${datasetType}"`
      });
    }
  }
  const bidsDerivatives = [];
  const nonstdDerivatives = [];
  fileTree.directories = fileTree.directories.filter((dir)=>{
    if ([
      'sourcedata',
      'code'
    ].includes(dir.name)) {
      return false;
    }
    if (dir.name !== 'derivatives') {
      return true;
    }
    for (const deriv of dir.directories){
      if (deriv.get('dataset_description.json')) {
        // New root for the derivative dataset
        deriv.parent = undefined;
        bidsDerivatives.push(deriv);
      } else {
        nonstdDerivatives.push(deriv);
      }
    }
    // Remove derivatives from the main fileTree
    return false;
  });
  for await (const context of walkFileTree(dsContext, 20)){
    if (dsContext.dataset_description.DatasetType == 'raw' && context.file.path.includes('derivatives')) {
      continue;
    }
    // Run majority of checks
    for (const check of perContextChecks){
      await check(schema, context);
    }
    await summary.update(context);
  }
  for (const check of perDSChecks){
    await check(schema, dsContext);
  }
  const modalitiesRule = schema.rules.modalities;
  const blacklistedDatatypes = new Map();
  if (options.blacklistModalities) {
    // Map blacklisted datatypes back to the modality that generated them
    for (const modality of options.blacklistModalities){
      const datatypes = modalitiesRule[modality.toLowerCase()]?.datatypes;
      if (datatypes) {
        for (const datatype of datatypes){
          blacklistedDatatypes.set(datatype, modality);
        }
      } else {
        logger.warn(`Attempted to blacklist unknown modality: ${modality}`);
      }
    }
  }
  const blacklistedDirs = fileTree.directories.filter((dir)=>dir.name.startsWith('sub-')).flatMap((dir)=>dir.directories).flatMap((dir)=>dir.name.startsWith('ses-') ? dir.directories : [
      dir
    ]).filter((dir)=>blacklistedDatatypes.has(dir.name));
  blacklistedDirs.forEach((dir)=>{
    dsContext.issues.add({
      code: 'BLACKLISTED_MODALITY',
      location: dir.path
    });
  });
  const derivativesSummary = {};
  if (options.recursive) {
    await Promise.allSettled(bidsDerivatives.map(async (deriv)=>{
      derivativesSummary[deriv.name] = await validate(deriv, options);
      return derivativesSummary[deriv.name];
    }));
  }
  if (config) {
    for (const level of [
      'ignore',
      'warning',
      'error'
    ]){
      for (const filter of config[level] ?? []){
        for (const issue of dsContext.issues.filter(filter).issues){
          issue.severity = level;
        }
      }
    }
  }
  if (options.ignoreWarnings) {
    dsContext.issues = dsContext.issues.filter({
      severity: 'error'
    });
  }
  const output = {
    issues: dsContext.issues,
    summary: summary.formatOutput()
  };
  if (Object.keys(derivativesSummary).length) {
    output['derivativesSummary'] = derivativesSummary;
  }
  return output;
}
//# sourceMappingURL=bids.js.map