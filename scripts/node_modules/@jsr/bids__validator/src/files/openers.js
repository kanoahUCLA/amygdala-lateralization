/**
 * BIDS file openers
 *
 * These classes implement stream, text and random bytes access to BIDS resources.
 */ import { join } from "@jsr/std__path";
import { createUTF8Stream } from "./streams.js";
export class FsFileOpener {
  path;
  fileInfo;
  constructor(datasetPath, path, fileInfo){
    this.path = join(datasetPath, path);
    if (fileInfo) {
      this.fileInfo = fileInfo;
    } else {
      try {
        this.fileInfo = Deno.statSync(this.path);
      } catch (error) {
        if (error && typeof error === 'object' && 'code' in error && error.code === 'ENOENT') {
          this.fileInfo = Deno.lstatSync(this.path);
        }
      }
    }
  }
  get size() {
    return this.fileInfo.size;
  }
  async stream() {
    const handle = await this.open();
    return handle.readable;
  }
  /**
   * Read the entire file and decode as utf-8 text
   */ async text() {
    const stream = await this.stream();
    const reader = stream.pipeThrough(createUTF8Stream()).getReader();
    const chunks = [];
    try {
      while(true){
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
      }
      return chunks.join('');
    } finally{
      reader.releaseLock();
    }
  }
  /**
   * Read bytes in a range efficiently from a given file
   *
   * Reads up to size bytes, starting at offset.
   * If EOF is encountered, the resulting array may be smaller.
   */ async readBytes(size, offset = 0) {
    const handle = await this.open();
    const buf = new Uint8Array(size);
    await handle.seek(offset, Deno.SeekMode.Start);
    const nbytes = await handle.read(buf) ?? 0;
    await handle.close();
    return buf.subarray(0, nbytes);
  }
  async open() {
    return Deno.open(this.path, {
      read: true,
      write: false
    });
  }
}
export class BrowserFileOpener {
  file;
  constructor(file){
    this.file = file;
  }
  get size() {
    return this.file.size;
  }
  async stream() {
    return Promise.resolve(this.file.stream());
  }
  async text() {
    return this.file.text();
  }
  async readBytes(size, offset = 0) {
    return new Uint8Array(await this.file.slice(offset, size).arrayBuffer());
  }
}
export class HTTPOpener {
  url;
  size;
  constructor(url, size = -1){
    this.url = url;
    this.size = size;
  }
  async stream() {
    const response = await fetch(this.url);
    if (!response.ok || !response.body) {
      throw new Error(`Failed to fetch ${this.url}: ${response.status} ${response.statusText}`);
    }
    return response.body;
  }
  async text() {
    const response = await fetch(this.url);
    return response.text();
  }
  async readBytes(size, offset = 0) {
    const headers = new Headers();
    headers.append('Range', `bytes=${offset}-${offset + size - 1}`);
    const response = await fetch(this.url, {
      headers
    });
    return new Uint8Array(await response.arrayBuffer());
  }
}
//# sourceMappingURL=openers.js.map