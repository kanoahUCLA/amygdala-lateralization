import { equal } from "@jsr/std__assert/equal";
import { brightBlue, dim, green, red } from "@jsr/std__fmt/colors";
import { Figures, getFiguresByKeys } from "./_figures.js";
import { GenericList, isOption, isOptionGroup } from "./_generic_list.js";
import { GenericPrompt } from "./_generic_prompt.js";
/**
 * Checkbox prompt representation.
 *
 * Simple prompt:
 *
 * ```ts
 * import { Checkbox } from "./mod.ts";
 *
 * const colors: Array<string> = await Checkbox.prompt({
 *   message: "Pick some colors",
 *   options: ["red", "green", "blue"],
 * });
 * ```
 *
 * Mixed option types:
 *
 * ```ts
 * import { Checkbox } from "./mod.ts";
 *
 * const values: Array<string | number> = await Checkbox.prompt<string | number>({
 *   message: "Pick some colors",
 *   options: [1, 2, "3", "4"],
 * });
 * ```
 *
 * None primitive option types:
 *
 * ```ts
 * import { Checkbox } from "./mod.ts";
 *
 * const dates: Array<Date> = await Checkbox.prompt({
 *   message: "Pick some dates",
 *   options: [
 *     {
 *       name: "Date 1",
 *       value: new Date(100000),
 *     },
 *     {
 *       name: "Date 2",
 *       value: new Date(200000),
 *     },
 *     {
 *       name: "Date 3",
 *       value: new Date(300000),
 *     },
 *   ],
 * });
 * ```
 *
 * Grouped options:
 *
 * ```ts
 * import { Checkbox } from "./mod.ts";
 *
 * const values = await Checkbox.prompt({
 *   message: "Select some values",
 *   options: [{
 *     name: "Group 1",
 *     options: ["foo", "bar", "baz"],
 *   }, {
 *     name: "Group 2",
 *     options: ["beep", "boop"],
 *   }],
 * });
 * ```
 */ export class Checkbox extends GenericList {
  settings;
  options;
  listIndex;
  listOffset;
  confirmSubmit = false;
  /**
   * Execute the prompt with provided options.
   *
   * @param options Checkbox options.
   */ static prompt(options) {
    return new this(options).prompt();
  }
  /**
   * Create list separator.
   *
   * @param label Separator label.
   */ /**
   * Inject prompt value. If called, the prompt doesn't prompt for an input and
   * returns immediately the injected value. Can be used for unit tests or pre
   * selections.
   *
   * @param value Input value.
   */ static inject(value) {
    GenericPrompt.inject(value);
  }
  constructor(options){
    super();
    this.settings = this.getDefaultSettings(options);
    this.options = this.settings.options.slice();
    this.listIndex = this.getListIndex();
    this.listOffset = this.getPageOffset(this.listIndex);
  }
  getDefaultSettings(options) {
    const settings = super.getDefaultSettings(options);
    return {
      confirmSubmit: true,
      ...settings,
      check: options.check ?? green(Figures.TICK),
      uncheck: options.uncheck ?? red(Figures.CROSS),
      partialCheck: options.partialCheck ?? green(Figures.RADIO_ON),
      minOptions: options.minOptions ?? 0,
      maxOptions: options.maxOptions ?? Infinity,
      options: this.mapOptions(options, options.options),
      keys: {
        check: [
          "space"
        ],
        checkAll: [
          "a"
        ],
        ...settings.keys ?? {},
        open: options.keys?.open ?? [
          "right"
        ],
        back: options.keys?.back ?? [
          "left",
          "escape"
        ]
      }
    };
  }
  /** Map string option values to options and set option defaults. */ mapOptions(promptOptions, options) {
    return options.map((option)=>typeof option === "string" || typeof option === "number" ? this.mapOption(promptOptions, {
        value: option
      }) : isCheckboxOptionGroup(option) ? this.mapOptionGroup(promptOptions, option) : this.mapOption(promptOptions, option));
  }
  mapOption(options, option) {
    if (isOption(option)) {
      return {
        ...super.mapOption(options, option),
        checked: typeof option.checked === "undefined" && options.default && options.default.indexOf(option.value) !== -1 ? true : !!option.checked,
        icon: typeof option.icon === "undefined" ? true : option.icon
      };
    } else {
      return {
        ...super.mapOption(options, option),
        checked: false,
        icon: false
      };
    }
  }
  mapOptionGroup(promptOptions, option) {
    const options = this.mapOptions(promptOptions, option.options);
    return {
      ...super.mapOptionGroup(promptOptions, option, false),
      get checked () {
        return areAllChecked(options);
      },
      options,
      icon: typeof option.icon === "undefined" ? true : option.icon
    };
  }
  match() {
    super.match();
    if (this.isSearching()) {
      this.selectSearch();
    }
  }
  getListItemIcon(option) {
    return this.getCheckboxIcon(option) + super.getListItemIcon(option);
  }
  getCheckboxIcon(option) {
    if (!option.icon) {
      return "";
    }
    const icon = option.checked ? this.settings.check + " " : isOptionGroup(option) && areSomeChecked(option.options) ? this.settings.partialCheck + " " : this.settings.uncheck + " ";
    return option.disabled ? dim(icon) : icon;
  }
  /** Get value of checked options. */ getValue() {
    return flatOptions(this.settings.options).filter((option)=>option.checked).map((option)=>option.value);
  }
  /**
   * Handle user input event.
   * @param event Key event.
   */ async handleEvent(event) {
    const hasConfirmed = this.confirmSubmit;
    this.confirmSubmit = false;
    switch(true){
      case this.isKey(this.settings.keys, "check", event) && !this.isSearchSelected():
        this.checkValue();
        break;
      case this.isKey(this.settings.keys, "submit", event):
        await this.submit(hasConfirmed);
        break;
      case event.ctrl && this.isKey(this.settings.keys, "checkAll", event):
        this.checkAllOption();
        break;
      default:
        await super.handleEvent(event);
    }
  }
  hint() {
    if (this.confirmSubmit) {
      const info = this.isBackButton(this.selectedOption) ? ` To leave the current group press ${getFiguresByKeys(this.settings.keys.back ?? []).join(", ")}.` : isOptionGroup(this.selectedOption) ? ` To open the selected group press ${getFiguresByKeys(this.settings.keys.open ?? []).join(", ")}.` : ` To check or uncheck the selected option press ${getFiguresByKeys(this.settings.keys.check ?? []).join(", ")}.`;
      return this.settings.indent + brightBlue(`Press ${getFiguresByKeys(this.settings.keys.submit ?? [])} again to submit.${info}`);
    }
    return super.hint();
  }
  async submit(hasConfirmed) {
    if (!hasConfirmed && this.settings.confirmSubmit && !this.isSearchSelected()) {
      this.confirmSubmit = true;
      return;
    }
    await super.submit();
  }
  /** Check selected option. */ checkValue() {
    const option = this.options.at(this.listIndex);
    if (!option) {
      this.setErrorMessage("No option available to select.");
      return;
    } else if (option.disabled) {
      this.setErrorMessage("This option is disabled and cannot be changed.");
      return;
    }
    this.checkOption(option, !option.checked);
  }
  checkOption(option, checked) {
    if (isOption(option)) {
      option.checked = checked;
    } else {
      for (const childOption of option.options){
        this.checkOption(childOption, checked);
      }
    }
  }
  checkAllOption() {
    const checked = this.options.some((option)=>option.checked);
    for (const option of this.options){
      this.checkOption(option, !checked);
    }
  }
  /**
   * Validate input value.
   * @param value User input value.
   * @return True on success, false or error message on error.
   */ validate(value) {
    const options = flatOptions(this.settings.options);
    const isValidValue = Array.isArray(value) && value.every((val)=>options.findIndex((option)=>equal(option.value, val)) !== -1);
    if (!isValidValue) {
      return false;
    }
    if (value.length < this.settings.minOptions) {
      return `The minimum number of options is ${this.settings.minOptions} but got ${value.length}.`;
    }
    if (value.length > this.settings.maxOptions) {
      return `The maximum number of options is ${this.settings.maxOptions} but got ${value.length}.`;
    }
    return true;
  }
  /**
   * Map input value to output value.
   * @param value Input value.
   * @return Output value.
   */ transform(value) {
    return value;
  }
  /**
   * Format output value.
   * @param value Output value.
   */ format(value) {
    return value.map((val)=>this.settings.format?.(val) ?? this.getOptionByValue(val)?.name ?? String(val)).join(", ");
  }
}
function areSomeChecked(options) {
  return options.some((option)=>isOptionGroup(option) ? areSomeChecked(option.options) : option.checked);
}
function areAllChecked(options) {
  return options.every((option)=>isOptionGroup(option) ? areAllChecked(option.options) : option.checked);
}
function flatOptions(options) {
  return flat(options);
  function flat(options, indentLevel = 0, opts = []) {
    for (const option of options){
      option.indentLevel = indentLevel;
      if (isOption(option)) {
        opts.push(option);
      }
      if (isOptionGroup(option)) {
        flat(option.options, ++indentLevel, opts);
      }
    }
    return opts;
  }
}
export function isCheckboxOptionGroup(option) {
  return isOptionGroup(option);
}
//# sourceMappingURL=checkbox.js.map