import { tty } from "@jsr/cliffy__ansi/tty";
import { getRuntimeName } from "@jsr/cliffy__internal/runtime/runtime-name";
import { parse } from "@jsr/cliffy__keycode";
import { bold, brightBlue, dim, green, italic, red, stripAnsiCode, yellow } from "@jsr/std__fmt/colors";
import { readSync } from "@jsr/cliffy__internal/runtime/read-sync";
import { writeSync } from "@jsr/cliffy__internal/runtime/write-sync";
import { Figures } from "./_figures.js";
import { exit } from "@jsr/cliffy__internal/runtime/exit";
import { getColumns } from "@jsr/cliffy__internal/runtime/get-columns";
import { isTerminal } from "@jsr/cliffy__internal/runtime/is-terminal";
import { read } from "@jsr/cliffy__internal/runtime/read";
import { setRaw } from "@jsr/cliffy__internal/runtime/set-raw";
/** Generic prompt representation. */ export class GenericPrompt {
  static injectedValue;
  cursor = {
    x: 0,
    y: 0
  };
  #value;
  #lastError;
  #isFirstRun = true;
  #encoder = new TextEncoder();
  /**
   * Inject prompt value. If called, the prompt doesn't prompt for an input and
   * returns immediately the injected value. Can be used for unit tests or pre
   * selections.
   *
   * @param value Input value.
   */ static inject(value) {
    GenericPrompt.injectedValue = value;
  }
  getDefaultSettings(options) {
    return {
      ...options,
      tty: tty({
        // Stdin is only used by getCursorPosition which we don't need.
        reader: {
          readSync,
          setRaw
        },
        writer: options.writer ?? {
          writeSync
        }
      }),
      cbreak: options.cbreak ?? false,
      reader: options.reader ?? {
        read,
        setRaw,
        isTerminal
      },
      writer: options.writer ?? {
        writeSync
      },
      pointer: options.pointer ?? brightBlue(Figures.POINTER_SMALL),
      prefix: options.prefix ?? yellow("? "),
      indent: options.indent ?? "",
      keys: {
        submit: [
          "enter",
          "return"
        ],
        ...options.keys ?? {}
      }
    };
  }
  /** Execute the prompt. */ async prompt() {
    try {
      return await this.#execute();
    } finally{
      this.settings.tty.cursorShow();
    }
  }
  /** Clear prompt output. */ clear() {
    this.settings.tty.cursorLeft.eraseDown();
  }
  /** Execute the prompt. */ #execute = async ()=>{
    // Throw errors on unit tests.
    if (typeof GenericPrompt.injectedValue !== "undefined" && this.#lastError) {
      throw new Error(this.error());
    }
    await this.render();
    this.#lastError = undefined;
    if (!await this.read()) {
      return this.#execute();
    }
    if (typeof this.#value === "undefined") {
      throw new Error("internal error: failed to read value");
    }
    this.clear();
    const successMessage = this.success(this.#value);
    if (successMessage) {
      this.settings.writer.writeSync(this.#encoder.encode(successMessage + "\n"));
    }
    GenericPrompt.injectedValue = undefined;
    this.settings.tty.cursorShow();
    return this.#value;
  };
  /** Render prompt. */ async render() {
    const result = await Promise.all([
      this.message(),
      this.body?.(),
      this.footer()
    ]);
    const content = result.filter(Boolean).join("\n");
    const lines = content.split("\n");
    const columns = getColumns();
    const linesCount = columns ? lines.reduce((prev, next)=>{
      const length = stripAnsiCode(next).length;
      return prev + (length > columns ? Math.ceil(length / columns) : 1);
    }, 0) : content.split("\n").length;
    const y = linesCount - this.cursor.y - 1;
    if (!this.#isFirstRun || this.#lastError) {
      this.clear();
    }
    this.#isFirstRun = false;
    this.settings.writer.writeSync(this.#encoder.encode(content));
    if (y) {
      this.settings.tty.cursorUp(y);
    }
    this.settings.tty.cursorTo(this.cursor.x);
  }
  /** Read user input from stdin, handle events and validate user input. */ async read() {
    if (typeof GenericPrompt.injectedValue !== "undefined") {
      const value = GenericPrompt.injectedValue;
      await this.#validateValue(value);
    } else {
      const events = await this.#readKey();
      if (!events.length) {
        return false;
      }
      for (const event of events){
        await this.handleEvent(event);
      }
    }
    return typeof this.#value !== "undefined";
  }
  submit() {
    return this.#validateValue(this.getValue());
  }
  message() {
    return `${this.settings.indent}${this.settings.prefix}` + bold(this.settings.message) + this.defaults();
  }
  defaults() {
    let defaultMessage = "";
    if (typeof this.settings.default !== "undefined" && !this.settings.hideDefault) {
      defaultMessage += dim(` (${this.format(this.settings.default)})`);
    }
    return defaultMessage;
  }
  /** Get prompt success message. */ success(value) {
    return `${this.settings.indent}${this.settings.prefix}` + bold(this.settings.message) + this.defaults() + " " + this.settings.pointer + " " + green(this.format(value));
  }
  footer() {
    return this.error() ?? this.hint();
  }
  error() {
    return this.#lastError ? this.settings.indent + red(bold(`${Figures.CROSS} `) + this.#lastError) : undefined;
  }
  hint() {
    return this.settings.hint ? this.settings.indent + italic(brightBlue(dim(`${Figures.POINTER} `) + this.settings.hint)) : undefined;
  }
  setErrorMessage(message) {
    this.#lastError = message;
  }
  /**
   * Handle user input event.
   * @param event Key event.
   */ async handleEvent(event) {
    switch(true){
      case event.name === "c" && event.ctrl:
        this.clear();
        this.settings.tty.cursorShow();
        exit(130);
        return;
      case this.isKey(this.settings.keys, "submit", event):
        await this.submit();
        break;
    }
  }
  /** Read user input from stdin and pars ansi codes. */ #readKey = async ()=>{
    const data = await this.#readChar();
    return data.length ? parse(data) : [];
  };
  /** Read user input from stdin. */ #readChar = async ()=>{
    const buffer = new Uint8Array(getRuntimeName() === "deno" ? 8 : 4096);
    const isTty = this.settings.reader.isTerminal();
    if (isTty) {
      this.settings.reader.setRaw(true, {
        cbreak: this.settings.cbreak
      });
    }
    const nread = await this.settings.reader.read(buffer);
    if (isTty) {
      this.settings.reader.setRaw(false);
    }
    if (nread === null) {
      return buffer;
    }
    return buffer.subarray(0, nread);
  };
  /**
   * Map input value to output value. If a custom transform handler ist set, the
   * custom handler will be executed, otherwise the default transform handler
   * from the prompt will be executed.
   * @param value The value to transform.
   */ #transformValue = (value)=>{
    return this.settings.transform ? this.settings.transform(value) : this.transform(value);
  };
  /**
   * Validate input value. Set error message if validation fails and transform
   * output value on success.
   * If a default value is set, the default will be used as value without any
   * validation.
   * If a custom validation handler ist set, the custom handler will
   * be executed, otherwise a prompt specific default validation handler will be
   * executed.
   * @param value The value to validate.
   */ #validateValue = async (value)=>{
    if (!value && typeof this.settings.default !== "undefined") {
      this.#value = this.settings.default;
      return;
    }
    this.#value = undefined;
    this.#lastError = undefined;
    const validation = await (this.settings.validate ? this.settings.validate(value) : this.validate(value));
    if (validation === false) {
      this.#lastError = `Invalid answer.`;
    } else if (typeof validation === "string") {
      this.#lastError = validation;
    } else {
      this.#value = this.#transformValue(value);
    }
  };
  /**
   * Check if key event has given name or sequence.
   * @param keys  Key map.
   * @param name  Key name.
   * @param event Key event.
   */ isKey(keys, name, event) {
    // deno-lint-ignore no-explicit-any
    const keyNames = keys?.[name];
    return typeof keyNames !== "undefined" && (typeof event.name !== "undefined" && keyNames.indexOf(event.name) !== -1 || typeof event.sequence !== "undefined" && keyNames.indexOf(event.sequence) !== -1);
  }
}
//# sourceMappingURL=_generic_prompt.js.map