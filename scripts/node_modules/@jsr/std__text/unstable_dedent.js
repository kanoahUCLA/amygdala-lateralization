// Copyright 2018-2025 the Deno authors. MIT license.
// This module is browser compatible.
import { longestCommonPrefix } from "./unstable_longest_common_prefix.js";
const WHITE_SPACE = String.raw`\t\v\f\ufeff\p{Space_Separator}`;
const INDENT_REGEXP = new RegExp(String.raw`^[${WHITE_SPACE}]+`, "u");
const WHITE_SPACE_ONLY_LINE_REGEXP = new RegExp(String.raw`^[${WHITE_SPACE}]+$`, "mu");
export function dedent(input, ...values) {
  // Substitute nonempty placeholder so multiline substitutions do not affect indent width.
  const joinedTemplate = typeof input === "string" ? input : input.join("x");
  const ignoreFirstUnindented = !joinedTemplate.startsWith("\n");
  const trimmedTemplate = joinedTemplate.replace(/^\n/, "").trimEnd();
  const lines = trimmedTemplate.split("\n");
  const linesToCheck = lines.slice(ignoreFirstUnindented && !INDENT_REGEXP.test(lines[0] ?? "") ? 1 : 0).filter((l)=>l.length > 0 && !WHITE_SPACE_ONLY_LINE_REGEXP.test(l));
  const commonPrefix = longestCommonPrefix(linesToCheck);
  const indent = commonPrefix.match(INDENT_REGEXP)?.[0];
  const inputString = typeof input === "string" ? input : String.raw({
    raw: input
  }, ...values);
  const trimmedInput = inputString.replace(/^\n/, "").trimEnd();
  // No lines to indent
  if (!indent) return trimmedInput;
  const minIndentRegex = new RegExp(String.raw`^${indent}`, "gmu");
  return trimmedInput.replaceAll(minIndentRegex, "").replaceAll(new RegExp(WHITE_SPACE_ONLY_LINE_REGEXP, WHITE_SPACE_ONLY_LINE_REGEXP.flags + "g"), "");
}
//# sourceMappingURL=unstable_dedent.js.map